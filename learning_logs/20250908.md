```python
class Student:
    def __init__(self, name, student_id):
        self.name: name
        self.student_id = student_id
        # 성적 저장을 위한 빈 딕셔너리 -> 과목명 key, 점수 value
        self._grades = {}
```

1. Java version의 setter / getter를 생성
   - 그런데 Java에서는 access modifier의 개념이 있어서 field를 
     private로 선언했다면 setter / getter는 준필수
   - 그러나 python에는 access modifer라는 개념이 없기에 모든 객체의  속성이 외부로 노출
2. 이러한 이유로 python에서는 `_속성명`을 명시할시 내부적으로만
   사용하는 변수라고 약속된 개념
3. name vs. _name
   - name 
     - 공개적으로 접근 가능한 속성(Public Attribute)
     - 클래스 외부에서 자유롭게 값을 읽고 쓸 수 있으며 다른 개발자가 이 변수 직접 사용 가능
     - `예시 : student.name = '김일'`처럼 직접 접근해 사용
   - _name
     - 내부용, 비공개  속성(Private Attribute)
     - python에는 Java와 같은 접근 제어자가 없어서 _를 이용해 외부 접근 금지 알림
     - 일반적으로 `@property` 데코레이터를 사용한 getter / setter를 경유해 간접 접근

### 생성자 특징
```python
class Student:
    # 생성자 정의
    def __init__(self, name, student_id):
        self._name = name
        self._student_id = student_id
        # 성적 저장을 위한 빈 딕셔너리 -> 과목명 key, 점수 value
        self._grades = {}
    
    # python 버전의 getter에 해당
    @property
    def name(self):
        return self._name

    # python 버전의 setter 예시
    @name.setter
    def name(self, value):
        self._name = value
student1 = Student('김일', 2025001)
# getter의 호출 예시 객체명.속성명 -> 객체명. 메서드명()이 아닌것에 주목
print(f'학생 이름 : {student1.name}')

# setter의 호출 예시
student1.name = '김영'
print(f'변경된 학생 이름 : {student1.name}')
```
Java를 기준으로만 python 코드를 생각하면 의문점이 발생하는데
1. _name이라는 속성이 있는데 객체명.name을 통해 김영 / 김일이라는 속성갑 출력
2. 객체명._name = '김영'이 아닌 객체명.name = '김영'으로 객체의 속성값을 직접 바꾼걸로 보인다는 점

이 발생

python에서는 _name / name이 서로 다른 개념이니 '_'는 파이썬 언어에서 내부적으로 동일한 속성

객체명.속성명에 ()가 없지만 메서드처럼 처리하기에 객체명.속성명은 getter로 처리하고 객체명.속성명=데이터 는 setter로 처리

이런 코드라인의 성립에 중요점이 `@property`와 `@속성명.setter`라는 데코레이터(decorator)

기본적으로 자동생성되니 일일히 애너테이션 달고 _속성명 / 일반 속성명을 따질 필요 없음

### JPA에서의 객체 생성 vs Python에서의 객체 생성
JPA(Java Persistence API)를 사용한 Java에서는 기본 생성자를 강제(springBoot 동일). 그런데 python은 매개변수 생성자를 권장하는데 두 언어간의 객체지향 패러다임과 데이터 관리 방식 차이 존재

1. Java(JPA)에서의 기본 생성자
   - JPA는 DB의 테이블과 (엔티티)클래스를 매핑해 객체를 관리(엔티티 클래스의 field가 DB 컬럼명). 이 과정에서 JPA가 직접 매개변수를 알 수는 어뵤기에 매개변수가 없는 기본 생성자를 먼저 호출해 객체를 생성하고 DB에서의 컬럼값들을 하나씩 필드에 값입. 이러한 이유로 JPA는 데이터 관리의 효율성을 위해 기본 생성자를 강제
```java
@Entity
@DataView
public class Student {
    private String name;
    private int studentCode;
    
    // 기본 생성자 강제
    public Student(){}
}

public class StudentMain {
    main {
        Student student1 = new Student;
        student1.setName('김일');
        student1.setStudentCode(2025001)
    }
}
```
이러한 코드라인처럼 필드에 아무 값이 없는 객체를 생성 후 DB 상에서의 테이블에 있는 값들을 일치하는 컬럼명을 조회해 집어넣는 과정을 거쳐 기본 생성자 강제

2. python에서의 매개변수 생성자
    - 파이썬은 Java와 달리 동적 타이핑(Dynamic Typing) 언어라고 해서 객체를 생성시 필수 속성들을 한 번에 초기화 권장
      1. 객체 무결성 보장 : init 메서드(생성자)에서 모든 필수 매개변수를 받으며 객체가 생성되는 시점에 이미 완전한 상태
      2. 명확한 코드 작성 : 클래스를 사용하는 사람이 어떤 정보가 필요한지 명확히 알 수 있는데 Java처럼 순서대로가 아닌 keyword argument 지원

그리고 python과 dv의 연동에 있어 JPA처럼 값을 하나씩 삽입보다는 ORM(Object-Relational Mapping) 라이브러리로 객체를 생성시 필요한 데이터를 직접 전달하는 방식으로 JPA오 차이점이 있어 기본 생성자 강제 필요 X

* 요약 : JPA는 DB와 연동하기 위한 기술적 제약으로 기본 생성자를 명시해야하는데(매개변수 생성자를 하나라도 정의하는 순간  기본 생성자도 정의해야하기에) python은 객체의 완전성과 가독성을 중시하는 언어적 특성상 매개변수 생성자를 권장

### Java와 python의 차이점
Java를 기준으로만 python 코드를 생각하면 의문점이 발생하는데
1. _name이라는 속성이 있는데 객체명.name을 통해 김영 / 김일이라는 속성갑 출력
2. 객체명._name = '김영'이 아닌 객체명.name = '김영'으로 객체의 속성값을 직접 바꾼걸로 보인다는 점이 발생

python에서는 _name / name이 서로 다른 개념이니 '_'는 파이썬 언어에서 내부적으로 동일한 속성

객체명.속성명에 ()가 없지만 메서드처럼 처리하기에 객체명.속성명은 getter로 처리하고 객체명.속성명=데이터 는 setter로 처리

이런 코드라인의 성립에 중요점이 `@property`와 `@속성명.setter`라는 데코레이터(decorator)

기본적으로 자동생성되니 일일히 애너테이션 달고 _속성명 / 일반 속성명을 따질 필요 없음

ex) 예제: 커피 머신
```python
MENU = {
    '에스프레소' : {
        '재료' : {
            '물' : 50,
            '커피' : 18,
        },
        '가격' : 1.5,
    },
    '라떼' : {
        '재료' : {
            '물' : 200,
            '우유' : 150,
            '커피' : 24,
        },
        '가격' : 2.5,
    },
    '카푸치노' : {
        '재료' : {
            '물' : 250,
            '우유' : 100,
            '커피' : 24,
        },
        '가격' : 3.0,
    },
}

# 실행 예
# 카푸치노에는 우유가 100ml 들어깁니다.
# 라고 콘솔에 출력할 수 있도록 카푸치노의 우유량을 추출하는 코드를 작성
print(f'카푸치노에는 우유가 {MENU['카푸치노']['재료']['우유']}ml 들어갑니다.')

# 에스프레소의 가격을 추출하시오.
print(MENU['에스프레소']['가격'])

# 라떼의 재료 이름만 추출하시오.
for i in MENU['라떼']['재료']:
    print(i, end=" ")
print()
print(" ".join(MENU['라떼']['재료'].keys()))

# 에스프레소 / 라떼 / 카푸치노를 50잔씩 만들때 필요한 커피 / 우유 / 물의 양은?

print()
coffee = 0
water = 0
milk = 0
for key in MENU:    # 결과값 : 에스프레소 / 라떼 / 카푸치노
    for key_key in MENU[key]['재료']:
        print(MENU[key]['재료'][key_key])
        if key_key == '커피':
            coffee += MENU[key]['재료'][key_key]
        elif key_key == '물':
            water += MENU[key]['재료'][key_key]
        else:
            milk += MENU[key]['재료'][key_key]

print(coffee*50)
print(water*50)
print(milk*50)


```
중요한 부분은 중첩 dictionary - JSON - 기타 collections들이 합쳐진 데이터에서 필요한 부분만 추출하기

일반적으로 list의 경우 index를 이용하기에 반복문만으로 해결되지만
dictionary는 key가 나와서 key를 이용해 value를 이용해 값을 계산
문제당 글자수가 30자 내외에 답변은 한두 단어 정도

call1() - call4() 구분 방식은 명확히 파악하기





2개 과목
1과목 - 서답형 / 50 문항
2과목 - 코드 작성 / 4개 문항

1과목 - 데이터 분석 기초 기술 활용=그냥 python
서답형으로 지난 java test와 도일
차이점은 python 리포지토리의 내용 위주(md파일 차고)
로직 자체는 2과목에서 처리할것이기에 이론 위주

문제당 글자수가 30자 내외에 답변은 한두 단어 정도

call1() - call4() 구분 방식은 명확히 파악하기
ex)문자열에서 공백을 기준으로 맨 앞글자만 대문자로 바꿔주는 메서드

2과목 - 빅데이터 분석 결과 시각화
전체 4문항 - 25/25/25/25

1 - 사용자로부터 전화번호를 입력 받아 특정 조건에 부합하는지 확인하고 전화번호 중간 4자리를 출력하는 프로그램을 작성. 전화번호는 하이픈(-)을 포함해 13자리(010-1234-5678)

지시사항:
1. 사용자로부터 전화번호를 입력받으시오
2. 입력된 전화번호의 길이가 13자리가 아니면 '유효하지 않은 전화번호 형식입니다.' 출력
3. 전화번호가 13자리면 중간 4자리(ex.1234)를 추출해 출력
4. 출력시 f-string을 사용

실행 예:
전화번호를 입력하시오 >>> 010-9876-5432 전화번호의 중간 4자리는 9876입니다.
전화번호를 입력하시오 >>> 010-1234-567 유효하지 않은 전화번호 형식입니다.