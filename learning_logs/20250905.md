# collections
## python 대표 collections
1. list 리스트 : 추가 / 수정 / 삭제가 언제나 가능 / 순서 있음
2. tuple 튜플 : 추가 / 수정 / 삭제가 불가능 / 순서 있음
3. set 세트 : 중복된 값의 저장이 불가능 / 순서 없음
4. dict 딕셔너리 : 키 + 값으로 관리

### list 
여러 값을 저장할 떄 가장 많이 사용. 자료형이 다르더라도 하나의 리스트에 저장 가능. 하나의 배열(파이썬에서 리스트와 비슷한 개념)에 동일한 자료형만 저장 가능한 C, Java에 비해 python의 장점 중 하나(그 외에는 JS)

1-1. list의 index / slice
list는 str과 동일한 index / slicing을 지원
1) 인덱스 / 마이너스 인덱스
2) slicing: str의 슬라이싱처럼 '시작인덱스:종료인덱스:증갑값' 구성
```python
li2 = [100, 3.14, 'hello']  # list 선언 및 초기화 방법 # 1
li3 = list([4,5,6,7,8,9,0])    # list 선언 및 초기화 방법 # 2
print(li3[0:4:2])   # 0번지부터 4번지 앞까지 2씩 증가시키며   # 결과값: [4, 6]
```
li3을 Java 버전으로 생각하면
String strExample = new String("안녕하세요"); 와 동일
String strExample = "안녕하세요"의 형식을 쓰지 않는다

3) list element의 추가와 삭제
list에 새로운 요소를 추가할 때는 .append() / .insert() 메서드 사용 가능. 기존 요소 삭제시 .pop() 메서드 사용
- .append() - 항상 마지막 인덱스에 element 추가 
- .insert(위치, 값) - 정채진 위치(인덱스)에 해당 값 추가

.pop()의 경우 빈 괄호로 사용시(call3 유형인 경우) 맨 마지막 요소 삭제. .pop(인덱스넘버)로 작성하면 해당 인덱스 마지막 요소 삭제
```python
scores = [30, 40, 50]
print(scores)
scores.append(100)
print(scores)
scores.insert(0, 90)
print(scores)
```
추가 삭제 메서드 : .remove(값)을 사용시 list 내에서 해당 값을 삭제(argument로 인덱스 넘버 요구가 아닌 데이터 요구)
```python
print(scores.remove(50))        # 결과값 : None / 특정값을 삭제했기에
print(scores)                   # 결과값 : [30, 40]
```

### tuple
저장된 값을 변경할 수 없는 list. 순서는 있어서 index 넘버와 slicing은 가능하나 저장된 값 이외에 추가 / 수정 / 삭제 불가능
소괄호를 이용해 생성

element 추출 및 slicing은 동일.
tuple의 특성상 element의 추가 /수정 / 삭제 역시 불가
```python
tu6 = 'hello.', 'good morning.', 'my name is', 'kim-il', 'i am', '20', 'years old.'
for i in tu6:
    print(i.title(), end=' ')   # 결과값 : Hello. Good Morning. My Name Is Kim-Il I Am 20 Years Old.
print()
print(tu6)
```
collection의 개볌과 내부 element의 자료형은 서로 다르다.
tuple의 정의는 내부 element의 추가 / 수정 / 삭제가 불가능한 colleciton이지만 element들은 가공이 가능. 가공해서 tuple에 대입 역시 불가능

### set
수학에서의 집합 개념. Java와 동일
```python
set1 = {1, 2, 3}   # 세트 생성 방법 # 1
set2 = set({4, 5, 6})   # 세트 생성 방법 # 2
print(set1)
print(set2)
```
se = {} 형태로 비어있는 set을 생성할 경우 se는 <class 'dict'>로 dictionary 자료형으로 출력
그래서 빈 set을 생성하려면 2번 형태가 필수

list / tuple은 index가 존재하는데 이 둘을 sequence라고 하고
set / dictionary의 경우 index가 없어서 비시퀀스라는 표현 사용(슬라이싱 x)
    
element 관련 메서드
1. .add() - set에 새로운 element 추가
2. .remove() - 기존 element 삭제
3. .discard() - 기존 element 삭제

```python
se3 = {10, 20, 30}
se3.add(50)
print(se3)  # 결과값 : {10, 20, 50, 30}
se3.remove(30)  # 순서가 없어서 값을 정확하게 입력
print(se3) # 결과값 : {10, 20, 50}

# remove() vs. discard()
# se3.remove(70)    # 오류 발생 - 갑을 정확하게 입력해야만 함
se3.discard(70)      # 오류 x. discard는 element 정확한 값 없으면 종료
print(se3)

# 향상된 for문으로 element 추출 가능하나 순서 보장 안됨
for element in se3:
    print(element)
```

### 4. dict(ionary)
Java에서의 Map / JS에서의 Object / JSON과 같은 형식      
```python
dict1 = {
    '이름':'김일',
    '나이':20,
    '주소':['서울특별시','마포구','목동'],
}
```
주소 라인 까지 key-value pair가 존재하는데 마지막 property에 콤마 찍어주는게 매너

딕셔너리에 인덱스는 존재하지 않지만 key를 인덱스와 유사하게 사용. 즉 key를 알면 값을 확인 가능

collections에서 중요한 것은 list만 고려하는게 아니라 set, tuple, dictionary 로 자료형 변경 / 가능 방식 / 쓸 상황등 종합적인 고려하는 역량이 중요

```python
# dictironary에서 property 추가 / 삭제
dict1['직업'] = '웹 퍼블리셔'      # 기존에 없는 키를 입력하고 value 지정
print(dict1)
dict1['직업'] = '웹 개발자'       # key 하나당 value는 고정이기에 재대입 발생
print(dict1)
# 삭제 방법
dict1.pop('직업')                # key를 알아야 삭제 가능 / .pop()의 return 특성 중요
print(dict1)
```

# Class
~~~
클래스 정의 형식 :

class 클래스명(파스칼케이스로):
    본문

객체 생성 형식 :
객체 이름 = 클래스명()
~~~

## 클래스의 구성

### 클래스의 기본 구성
객체를 만들어내는 클래스는 객체가 가져야 할 구성 요소를 보유
객체를 생성하기 위해서는 객체가 지녀야 할 값과 기능 필요

값 = 속성(attribute)
기능 = 메서드(method)

클래스를 구성하는 속성은 두 가지로 구분

1) 클래스 변수 : 클래스를 기반으로 생성된 모든 인스턴스들이 공유하는 변수
(Java에서는 static 변수)
2) 인스턴스 변수 : 인스턴스들이 개별적으로 가지는 변수

메서드는 특징에 따라서

1) 클래스 메서드
2) 정적 메서드
3) 인스턴스 메서드

가 있는데 Java에서 정적 메서드 분류가 클래스 메서드에 해당되고 정적 메서드는 또 따로 있다고 볼 수 있고 Java의 정적 메서드가 파이썬 클래스의 정적 메서드라고 볼 수 있음

그리고 Java에서 this를 사용했는데(아직 생성되지 않은 객체명을 도입 할 수 없어서 사용하는 키워드 python은 self 사용

self 키워드
인스턴스 변수에서 각각의 객체를 의미하기 위해 self 키워드 사용
인스턴스 메서드에서의 첫 매개변수로 항상 self 추가

ex) 예제
```python
# 클래스 정의
class Person:
    # 메서드 정의(함수가 클래스 내에 존재하기에)
    def set_info(self, name, age, tel, address):
        self.name = name
        self.age = age
        self.tel = tel
        self.address = address

    def show_info(self):
        print(f'이름 : {self.name}')
        print(f'나이 : {self.age}')
        print(f'연락처 : {self.tel}')
        print(f'주소 : {self.address}')

    def show_info2(self):
        return f'제 이름은 {self.name}이고, {self.age}살입니다.\n연락처는 {self.tel}이며, {self.address}에 살고 있습니다.'
# 객체 생성
person01 = Person()
# Person 클래스의 메서드 호출
person01.set_info('김일',20,'010-1234-5678','서울특별시 마포구')
person01.show_info()
```
#### 속성값을 대입하지 않은 객체를 생성한 후 속성값을 집어넣기
매개변수 생성자를 정의하면 객체 생성시 속성값을 넣을 수 있음
```python
# 클래스 정의
class Candy:
    def set_info(self, shape, color):
        self.shape = shape
        self.color = color

    def show_info(self):
        print(f'사탕의 모양은 {self.shape}이고 색깔은 {self.color}입니다.')

# 객체 생성(빈 객체 -> 속성값 대입 -> 속성값 출력))
satang = Candy()
satang.set_info('구형', '갈색')
satang.show_info()
```
속성값에 대한 제한이 있지 않으면 빈 객체를 생성하고 거기에 값 대입이 비효율적이니 생성자를 도입

Java / JS 등에서는 생성자 명은 클래스명과 동일하거나 constructor이지만 python은 다른 형태의 생성자 사용

#### 소멸자
```python
# 객체 생성방식에서 차이 존재
class Candy2:
    # 생성자 정의
    def __init__(self, shape, color):   # __init__ : 생성자
        self.shape = shape
        self.color = color

    def show_info(self):
        print(f'사탕의 모양은 {self.shape}이고 색깔은 {self.color}입니다.')

satang2 = Candy2('정육면체', '흰색')
satang2.show_info()

class Sample:
    # 생성자 정의
    def __init__(self):
        print('인스턴스가 생성되었습니다.')
    # 소멸자 정의
    def __del__(self):
        print('인스턴스가 소멸되었습니다.')

# 객체 생성
sample = Sample()
print()
# 객체 소멸자 호출 방법
del sample      # del 객체명
print('객체 지운 후의 코드라인')
```
소멸자가 필요한 이유 -> 객체가 생성되면 메모리 공간을 차지해서 객체가 호출될때 마다 소환되는데

하지만 특정 객체가 일정 코드라인 이후로 전혀 사용되지 않을 때에도 여전히 메모리를 차지하기 때문에
소멸자를 통해서 강제로 객체를 삭제하면 메모리 관리에 용이

ex) 예제: USB 만들기
```python
class USB:
    def __init__(self, capacity):
        print('USB 정보가 생성되었습니다.')
        self.capacity = capacity
    def get_info(self):
        print(f'{self.capacity}GB')
usb = USB(64)
usb.get_info()
```