# 예외처리(Exception)
## 1. 예외 처리의 필요성
1) 예외(exception) : 개발자가 직접 처리가능한 문제
2) 오류(error) : 개발자가 처리할 수 없는 문제
3) 예외 처리의 목적 :
어떤 문제가 발생했을 때 그 문제를 해결하는게 아니라 발생된 문제로 인해 프로그램이
비정상적 종료를 막고 사용자에게 발생한 문제에 대해 정보 전달을 목적

```python
a = int(input('나누는 수(제수)를 입력하세요 >>> '))
b = int(input('나누어지는 수(피제수)를 입력하세요 >>> '))
if a == 0:
    print('0으로 나눌 수 없습니다')
else:
    result = b / a
    print(result)
```

## 2. 예외 처리
### 고전적 예외 처리
어떤 갑싱든 0으로는 나눌수 없기에 if a == 0으로 0을 나누기 자체를 시도할 수 없게 예외처리

핵심 포인트 : 
1) 어떤 문제가 발생할 지 예상해야 대비 가능
2) 어떤 문제가 발생할 지 예상해도 대비할 수 없는 경우 발생

## 3. 예외 처리의 종류
~~~
+------+---------------------+--------------------------------------------+
| 순번  |     예외 클래스       |                    의미                    |
+------+---------------------+--------------------------------------------+
|  1   |    BaseException    |             최상위 예외 클래스                |
|  2   |      Exception      |        대부분 예외 클래스의 슈퍼 클래스         |
|  3   |   ArithmeticError   |           산술 연산에 문제가 있을 때           |
|  4   |    AttributeError   |            잘못된 속성을 참조할 때             |
|  5   |       EOFError      |     파일에서 더 이상 읽어들일 데이터가 없을 때    |
|  6   | ModuleNotFoundError |           import할 모듈이 없을 때             |
|  7   |  FileNotFoundError  |            존재하지 않는 파일일 때             |
|  8   |      IndexError     |          잘못된 인덱스를 사용할 때             |
|  9   |      NameError      |         잘못된 이름(변수)을 사용할 때           |
|  10  |     SyntaxError     |              문법이 틀렸을 때                 |
|  11  |      TypeError      |     계산하려는 데이터의 유형이 잘못되었을 때      |
|  12  |      ValueError     |      계산하려는 데이터의 값이 잘못되었을때        |
+------+---------------------+--------------------------------------------+
~~~
## 4. 예외 처리 방식
### 1. 모든 예외를 처리하는 방식 -> try / except / finally

형식 :
~~~
try : 
    코드 작성 영역
except :
    예외 발생 시 처리 영역
finally :
    언제나 실행되는 영역
~~~

```python
try :
    a = int(input('나누는 수를 정수로 입력하세요 >>> '))
    b = int(input('나누어지는 수를 정수로 입력하세요 >>> '))
    result = b / a      # 예외 발생 가능한 구간이 try문 내에 있어야 함
    print(result)
except ZeroDivisionError as e :
    print(e)
except TypeError as e :
    print(e)
except ValueError as e :
    print(e)
except Exception as e :
    print(e)
else :
    print(f'b / a = {b / a}')
finally :
    print('프로그램 종료')
```
개발자가 고려해야할 것은 try를 쓰면 except를 쓰지 않을 때 오류가 발생하기 때문에 try / except문이 없는 상태에서 다양하게 검증하고 어떤 예외가 발생하는지 체크.
그리고 그 발생한 예외들에 대한 except문을 작성하고 정상적 처리가 되면 else문을 쓸 이유 존재

하지만 이상의 사례와 같이 a = 0 을 입력하는것 자체가 예외를 발생시키지 않고 
1. a = 0 이며
2. b / a 연산을 시도할 때 ZeroDivisionError가 발생해서

else문에 b / a가 포함되면 안된다. 그래서 try문 내에 result = b / a를 넣어 그 부분이 예외 없이 통과되면 연산 결과가 출력되게 `print(f'b / a = {result}')`로 정리

### 2. 특정 예외 처리
try / except 문을 사용하면 기본적으로 예외의 종류와 상관없이 모든 예외가 처리.
하지만 서로 다른 메세지를 출력할 수 있으면 개발자에게 예외를 처리할만한 추가 정보 제공 가능

1) 0으로 나누는 경우 -> 0으로 나눌 수 없습니다
2) 정수가 아닌 값을 입력히는 경우 -> 정수만 입력할 수 있습니다 

등으로 특정 예외에 서로 다른 안내문을 제시한다고 하면 except문 뒤에 처리하고자 하는 예외를 모두 명시

거의 모든 예외는 Exception 클래스의 서브 클래스에 해당해 따라서 모든 예외는 Exception의 인스턴스가 되서 except 마지막에 Exception을 명시하면 예상치 못한 예외들도 처리 가능

~~~
형식 :
try :
    코드 작성 영역
except 예외클래스1 :
    예외메세지1
except 예외클래스2 :
    예외메세지2
...
except Exception:
    예외메세지n
finally : 
    항시 실행되는 코드 영역
~~~



Java에서와 동일하게 Exception이 가장 상위에 있으면 모든 예외가 전부 Exception으로 잡히기에 순서도 중요

### 3. 예외 메세지 처리하기

이상까지는 특정 예외갑 라생시 메세지를 커스텀했지만 기본적으로 이미 예외메세지를 보유한 경우 존재
default exception message를 출력하는 방식 학습
~~~
형식 :
try :
    코드 작성 영역
except 예외클래스 as 예외메세지:
    예외 발생 시 처리 영역
~~~
### 4. else / finally 
try / excepted 문에 else / finally를 달 수 있는데

- else : 예외가 발생하지 않으면 처리되는 구문
- finally : 예외 발생 여부와 관계없이 맨 마지막에 처리되는 구문

### 5. 강제로 예외를 발생시키기
어떤 사람이 나이를 정수로 입력받는 프로그램을 사용한가고 가정했을 때
컴퓨터 상으로는(=파이썬 상으로는) -1000이 정수이기에 예외가 발생하지 않으나
-1000살이 도니느건 불가능해서 조건문이 아닌 직접 예외를 발생시켜 처리 -> raise문
~~~
형식 :
raise 예외클래스()

또는
raise 예외클래스(예외메세지)
~~~
raise의 경우 강제로 예외를 발생시키는 점에서 주로 사용되는 예외클래스는 Exception

```python
age = int(input('나이를 입력하세요 >>> '))      # -1000을 입력해도 예외 발생 없음
print(f'당신의 나이는 {age}살입니다')

try :
    age = int(input('나이를 입력하세요 >>> '))
    if age < 0 or age > 200 :
        raise Exception('강제로 발생시킨 예외')
except Exception as e :
    print('발생한 예외 메세지')
    print(e)
```
이상은 특정 예외가 아닌 raise로 넘어가려면 바로 예외 발생.
즉 age에 가능한 정수값을 넣어도 예외가 발생해서 단독으로 처리가 불가능.
그렇기에 이 부분은 조건문을 이용해 특정 조건일때만 예외로 넘기는 추가 코드가 필요.

### 6. 사용자 정의 예외 클래스
음수를 입력 받을때 강제로 예외를 발생시키는 예외 클래스 정의
```python
class NegativeAgeError(Exception):      # Exception 클래스를 상속받았다는 의미
    pass
```
사용자 정의 예외 클래스 : 나이가 음수일 때 발생
- 예외를 발생시키기만 하면 되기에 굳이 코드를 쓸 필요는 없고
- Exception 클래스를 상속받았으면 슈퍼 클래스의 속성/method를 사용 가능



# 상속(Inheritance)
```python
class Person:
    def __init__(self, name):
        self.name = name

    def eat(self, food):
        print(f'{self.name} 이(가) {food}을(를) 먹습니다')

class Student(Person):
    def __init__(self, name, school):
        super().__init__(name)
        self.school = school
    
    def study(self):
        print(f'{self.name}은(는) {self.school}에서 공부를 합니다')

# 객체 생성
potter = Student('해리 포터','호그와트')
potter.eat('감자')
potter.study()
```
이상의 코드에서 주목할 점은
1. Student 클래스에 정의되지 않은 메서드인 .eat()를 potter.eat('감자')에서 호출
2. Student 클래스의 생성자에서 확인되는 'super(().__init__(name)'
    - 해당 부분은 슈퍼 클래스의 생성자 호출 방식
    - Java에서는 슈퍼 클래스의 생성자 호출 방식이 super()
    - Javba에서는 슈퍼 클래스이 메서드 호출 방식 super.메서드명())
```python
    def eat(self, food):
        print(f'{self.school}에서', end=' ')
        super().eat(food)
```
위 코드처럼 슈퍼클래스의 메서드인 .eat()을 override해 `재정의`하는 것이 가능.
Java와 달리 python에서 기본적으로 `super().`을 베이스로 하는데 생성자나 소멸자가 __ 앞뒤로 붙기는 하지만 기본적으로 method이기에 더 일괄적인 방식으로 코드 작성 가능



## 추가: field_names

테이블의 필드 이름(열 헤더)을 설정하거나 가져오는 데 사용

사용법:
```python
table = PrettyTable()
table.field_names = ["필드1", "필드2", "필드3"]
```

설명:
- 필드 이름 설정: `field_names`에 문자열 리스트를 할당하여 테이블의 헤더를 정의
- 필드 이름 가져오기: `field_names`를 액세스하면 현재 헤더를 가져온다

### add_row

이 메서드는 테이블에 단일 행을 추가하는 데 사용

**사용법:**

```python
table.add_row(("값1", "값2", "값3"))
```

설명:
- 행 추가: `field_names`에 정의된 각 필드에 해당하는 값 리스트를 제공. 리스트의 값 개수는 필드 이름의 개수와 일치해야 함