# coffe_machine_oop 예제

```python
MENU = {
    '에스프레소' : {
        '재료' : {
            '물' : 50,
            '커피' : 18,
        },
        '가격' : 1.5,
    },
    '라떼' : {
        '재료' : {
            '물' : 200,
            '우유' : 150,
            '커피' : 24,
        },
        '가격' : 2.5,
    },
    '카푸치노' : {
        '재료' : {
            '물' : 250,
            '우유' : 100,
            '커피' : 24,
        },
        '가격' : 3.0,
    },
}
profit = 0
resources = {
    '물' : 300,
    '우유' : 200,
    '커피' : 100,
}
'''
현재 자판기 내에 있는 물 / 우유 / 커피 양에서 라떼 한 잔을 내리면 물 / 우유 / 커피 / 금액의 변동을 콘솔에 출력

실행 예 
물 : ml
우유 : ml
커피 : ml
수익 : $
'''
profit += MENU['라떼']['가격']

# resources['물'] -= MENU['라떼']['재료']['물']
# resources['우유'] -= MENU['라떼']['재료']['우유']
# resources['커피'] -= MENU['라떼']['재료']['커피']

for i in MENU['라떼']['재료']:
    resources[i] -= MENU['라떼']['재료'][i]

print('실행 예')
print(f'물 : {resources['물']}ml')
print(f'우유 : {resources['우유']}ml')
print(f'커피 : {resources['커피']}ml')
print(f'수익 : {profit}$')
```
이전자에서는 dict 내부의 value를 조회하는데 그쳤지만 금일은 필요한 value를 다양한 방법으로 추출 후 연산까지 처리
sql문에서도 각각 컬럼에 있는 값들을 필요한것만 추출해 연산 후 집계합수를 쓰는 등 응용이 있을수 있어 python 작성법 외에 원리 학습

```python
class MenuItem:
    """각 메뉴 아이템들을 모델링합니다."""
    def __init__(self, name, water, milk, coffee, cost):
        self.name = name
        self.cost = cost
        self.ingredients = {
            "water": water,
            "milk": milk,
            "coffee": coffee,
        }


class Menu:
    """음료 메뉴를 모델링합니다."""
    def __init__(self):
        self.menu = [
            MenuItem(name="latte", water=200, milk=150, coffee=24, cost=2.5),
            MenuItem(name="espresso", water=50, milk=0, coffee=18, cost=1.5),
            MenuItem(name="cappuccino", water=250, milk=50, coffee=24, cost=3),
            # MenuItem(name="카라멜마키아토", water=200, milk=60, coffee=26, cost=4),
        ]

    def get_items(self):
        """이용 가능한 모든 메뉴 아이템의 이름을 반환합니다."""
        options = ""
        for item in self.menu:
            options += f"{item.name}/"
        return options

    def find_drink(self, order_name):
        """특정 음료를 이름으로 메뉴에서 검색합니다. 해당 아이템이 존재하면 반환하고, 그렇지 않으면 None을 반환합니다."""
        for item in self.menu:
            if item.name == order_name:
                return item
        print("죄송합니다. 해당 아이템은 이용할 수 없습니다.")
```
이상의 코드에서 python에서 잘 보지 못한 부분들 검증
```python
def __init__(self, name, water, milk, coffee, cost):
        self.name = name
        self.cost = cost
        self.ingredients = {
            "water": water,
            "milk": milk,
            "coffee": coffee,
        }
```
class MenuItem은 객체를 생성시 이름, 물, 우유, 커피, 가격을 매개변수로 받는데 여태까지는 
```python
class MenuItem
def __init__(self, name, water, milk, coffee, cost):
    self.name = name
    self.water = water
    self.milk = milk
    self.coffee = coffee
    self.cost = cost
```
형태와 달리 water / milk / coffee 매개변수들은 전부 ingredient라는 매개변수에 속하지 않은 속성의 value 값으로 지정. Java / Springboot / Python 상에서 객체의 field / instance variable들이 매개변수 생성자의 argument들과 반드시 일치하지 않는 경우 발생

```python
def __init__(self):
    self.menu = [
        MenuItem(name="latte", water=200, milk=150, coffee=24, cost=2.5),
        MenuItem(name="espresso", water=50, milk=0, coffee=18, cost=1.5),
        MenuItem(name="cappuccino", water=250, milk=50, coffee=24, cost=3),
        # MenuItem(name="카라멜마키아토", water=200, milk=60, coffee=26, cost=4),
    ]
```
이러한 코드에서 menu 객체를 생성한다면
```python
menu = Menu()
```
라고 생성. 그렇다면 menu라는 객체를 생서앟면 menu.menu라는 인스턴스 변수가 존재. 그러면 그 인스턴스 변수의 자료형은 list가 될것이고 내부 element 자료형은 MenuItem의 객체. 또한 MenuItem 객체를 생성할 때 반드시 name / water / milk / coffee / cost를 요구해서 
`MenuItem(name="latte", water=200, milk=150, coffee=24, cost=2.5)`
형식으로 작성

즉 menuItem =  MenuItem(name="latte", water=200, milk=150, coffee=24, cost=2.5) 로 이해

매개변수 생성자를 호출해 name / water / milk / coffee / cost를 keyword argument로 값을 넣고 menu.menu의 0/1/2 번지에 집어넣는다면

```java
public class Main {
    main {
        Student[] student = new Student(new MiddleSchool(), new HighSchool());
    }
}
```
의 형태로 Java에서 객체 생성시 내부 element로 new 생성자(); 형태로 객체의 이름이 없는 객체를 만들어 element로 사용했던것과 같은 예시

```python
def process_coins():
    """동전들을 입력 받아 전체 금액을 반환하는 함수 call3() 유형"""
    sum = 0
    sum += float(input('쿼터 동전을 몇 개나 넣으시겠습니까? >>> ')) * 0.25
    sum += float(input('다임 동전을 몇 개나 넣으시겠습니까? >>> ')) * 0.1
    sum += float(input('니켈 동전을 몇 개나 넣으시겠습니까? >>> ')) * 0.05
    sum += float(input('페니 동전을 몇 개나 넣으시겠습니까? >>> ')) * 0.01
    return sum

def is_transaction_successful(money_received, drink_cost):
    """process_coins()의 결과값과 음료 가격을 매개변수로 받아 받은 동전의 총합이 음료 가격보다 높으면 True / 아니면 False 반환. 그리고 True인 경우에는 profit에 음료 가격만큼 추가해줘야 하고, False인 경우에는 받은 동전들을 반환해주는 안내문 출력."""
    change = money_received - drink_cost
    if change >= 0:
        global profit
        profit += drink_cost
        print(f'잔돈 ${change}을(를) 반환합니다.')
        return True
    else:
        print(f'금액이 충분하지 않습니다. ${money_received}를 반환합니다.')
        return False

    def process_coins(self):
        """투입된 동전으로부터 계산된 총액을 반환합니다."""
        print("동전을 투입해주세요.")
        for coin in self.COIN_VALUES:
            self.money_received += int(input(f"{coin}는 몇 개입니까?: ")) * self.COIN_VALUES[coin]
        return self.money_received

    def make_payment(self, cost):
        """지불이 성공했을 때 True를 반환하고, 돈이 부족하면 False를 반환합니다."""
        self.process_coins()
        if self.money_received >= cost:
            change = round(self.money_received - cost, 2)
            print(f"여기 잔돈 {self.CURRENCY}{change}를 반환합니다.")
            self.profit += cost
            self.money_received = 0
            return True
        else:
            print("죄송합니다. 돈이 충분하지 않습니다. 돈을 반환합니다.")
            self.money_received = 0
            return False
```
이상의 코드는 pop version의 process_coins()/is_transaction_successful()과 oop version의 process_coins()/make_payment

주목할 점은 make_payment() 내부에서 process_coins()를 호출하는점인데 pop version의 main은 process_coins()를 호출해 money_recieved에 저장할 필요가 있지만 oop는 make_payment()만 호출해도 process_coins()의 결과값이 나온다

그 결과로 is_transaction_successful()를 정의할 때 두 개의 매개변수가 필요

하지만 make_payment()는 내부에서 process_coins()를 호출해서 하나의 매개변수만 있으면 된다

### 최종본
```python
# mainMenu
from menu import Menu
from coffee_maker import CoffeeMaker
from money_machine import MoneyMachine

menu = Menu()
coffee_maker = CoffeeMaker()
money_machine = MoneyMachine()

is_on = True
while is_on:
    choice = input(f'어떤 음료를 드시겠습니까 ({menu.get_items()}) >>> ')

    if choice == 'off':
        is_on = False
        print('자판기가 종료되었습니다')

    elif choice == 'report':
        coffee_maker.report()
        money_machine.report()

    else:
        drink = menu.find_drink(choice)
        if drink == None:
            continue
        if coffee_maker.is_resource_sufficient(drink):
            if money_machine.make_payment(drink.cost):
                coffee_maker.make_coffee(drink)
                
                
# coffee_maker
class CoffeeMaker:
    def __init__(self):
        self.resources = {
            "water": 300,
            "milk": 200,
            "coffee": 100,
        }

    def report(self):
        print(f"물: {self.resources['water']}ml")
        print(f"우유: {self.resources['milk']}ml")
        print(f"커피: {self.resources['coffee']}g")

    def is_resource_sufficient(self, drink):
        can_make = True
        for item in drink.ingredients:
            if drink.ingredients[item] > self.resources[item]:
                print(f"죄송합니다. {item}가(이) 충분하지 않습니다.")
                can_make = False
        return can_make

    def make_coffee(self, order):
        for item in order.ingredients:
            self.resources[item] -= order.ingredients[item]
        print(f"여기 {order.name}입니다. 맛있게 드세요!")
        
        
# money_machine
class MoneyMachine:

    CURRENCY = "$"

    COIN_VALUES = {
        "quarters": 0.25,
        "dimes": 0.10,
        "nickles": 0.05,
        "pennies": 0.01
    }

    def __init__(self):
        self.profit = 0
        self.money_received = 0

    def report(self):
        print(f"수익: {self.CURRENCY}{self.profit}")

    def process_coins(self):
        print("동전을 투입해주세요.")
        for coin in self.COIN_VALUES:
            self.money_received += int(input(f"{coin}는 몇 개입니까?: ")) * self.COIN_VALUES[coin]
        return self.money_received

    def make_payment(self, cost):
        self.process_coins()
        if self.money_received >= cost:
            change = round(self.money_received - cost, 2)
            print(f"여기 잔돈 {self.CURRENCY}{change}를 반환합니다.")
            self.profit += cost
            self.money_received = 0
            return True
        else:
            print("죄송합니다. 돈이 충분하지 않습니다. 돈을 반환합니다.")
            self.money_received = 0
            return False
```


# static class
## # 1. 클래스 변수 vs. 인스턴스 변수
인스턴스 변수 : 인스턴스마다 서로 다른 값을 가지는 변수
클래스 변수 : 모든 인스턴스가 동일한 값을 지는 변수(Java는 정적 변수)

인스턴스 변수 :
    목적 - 인스턴스마다 서로 다른 값을 저장
    접근 방식 - 인스턴스 접근(o)
            - 클래스 접근(x)

클래스 변수 :
    목적 - 인스턴스가 공유하는 값을 저장
    접근 방식 - 인스턴스 접근(o)
            - 클래스 접근(o)
객체명.클래스 변수를 통해서 클래스 변수에 접근이 가능하나 클래스 내부의 코드를 들여다보기 전까지는 
country라는 변수가 인스턴스인지 클래스 변수인지 알 방법이 없다

그래서 클래스 변수를 확인할 떄는 객체명.클래스변수보다는 클래스명.클래스변수를 권장

## # 2. 클래스 메서드 : 클래스 변수를 사용하는 메서드

특징 :
  1) 인스턴스 / 클래스로 호출 가능 -> 하지만 클래스로 호출하게 권장
  2) 생성된 인스턴스가 없어도 호출 가능(클래스로 호출 가능)
  3) @classmethod 데코레이터(decorator)를 표시하고 작성
  4) 매개변수 cls를 사용 -> self는 객체를 의미하고 cls는 클래스를 의미
    

## # 3. 정적 메서드(static method)
정적 메서드 또한 self를 사용하지 않음 -> 즉 인스턴스 변수에 접근해 사용하는것이 불가능
self. 속성명을 사용해 인스턴스 변수의 값을 참조하는데 
정적 메서드는 아예 첫 번째 매개변수가 고정이 아님 - 클래스 메서드와의 공통점 # 1
인스턴스를 생성하지 않아도 사용 가능 - 클래스 메서드와의 공통점 # 2
  
특징 :
  1) 인스턴스 / 클래스로 호출 가능 -> 클래스 메서드와의 공통점
  2) 생성된 인스턴스가 없어도 호출 가능 -> 클래스 메서드와의 공통점
  3) @staticmethod 데코레이터를 표기하고 작성 -> 클래스 메서드와의 차이점 # 1
  4) 반드시 작성해야 할 매개변수(self / cls)가 없음 -> 클래스 메서드와의 차이점 # 2

이러한 이유로 정적 메서드는 self / cls 둘 다 사용하지 않아서 인스턴스 / 클래스 변수를 모두 사용하지 않는 메서드 정의에 적합
정적 메서드는 클래스에 소속되있지만 인스턴스에 영향 없음

즉 Java에서의 정적 메서드 = 파이썬의 클래스 메서드 + 정적 메서드
```python
class Person:
    # 클래스 변수의 선언 및 초기화
    population = 0
    
    @classmethod
    def get_population(cls):
        return f'전체 인구수 : {cls.population}'
    
    def __init__(self,name):
        self.name = name
        Person.population +=1    # 인스턴스 메서드를 통해 클래스 변수를 변화시킨거니 클래스명.클래스변수명
        print(f'{self.name}이(가) 태어났습니다.')

    def __del__(self):
        Person.population -= 1
        print(f'RIP {self.name}')

man = Person('김일')
woman = Person('김이')
print(f'전체 인구수 : {Person.get_population()}')
del man
print(f'전체 인구수 : {Person.get_population()}')
print('프로그램 종료')
```
이상의 코드에서는 
- 특정 메서드가 인스턴스/클래스/정적 메서드 중 무엇이 되야 하는가
  - 클래스 변수가 있어도 인스턴스 변수가 포함되면 인스턴스 메서드로 작성
    - 클래스 메서드는 특정 인스턴스를 불러낼 수 없음
    - 반면 인스턴스 메서드는 모든 인스턴스가 공유하는 클래스 변수를 클래스명.클래스 변수명 호출 가능
- 이상의 내용을 생각하면 소멸자의 정의는 객체의 소멸을 정의하는 메서드이기에 특정 객체에 가해지는 작용이라고 볼 수 있고 또한 `RIP 김일`이라는 점에서 객체명.name이라는 인스턴스 변수를 참조해야하기에 population -= 1을 쓰더라도 인스턴스 메서드로 정의